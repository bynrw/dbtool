package de.dbmigration;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.sql.*;
import java.util.*;
import java.util.List;

public class SQLImporter {
    
    private static Map<String, Properties> verbindungen = new HashMap<>();
    
    public static void main(String[] args) {
        // Properties-Datei laden
        String configFile = args.length > 0 ? args[0] : "config-sqlimporter.properties";
        
        if (!ladeAlleVerbindungen(configFile)) {
            System.err.println("FEHLER: Konnte Konfiguration nicht laden!");
            return;
        }
        
        // Benutzer Verbindung wählen lassen
        String gewaehlteVerbindung = waehleVerbindung();
        
        if (gewaehlteVerbindung == null) {
            System.err.println("Keine Verbindung gewählt. Abbruch.");
            return;
        }
        
        Scanner scanner = new Scanner(System.in);
        
        // Automatisch migrierte_daten durchsuchen
        List<String> migrationOrdner = findeAlleMigrationOrdner();
        
        if (migrationOrdner.isEmpty()) {
            System.err.println("FEHLER: Keine Migration-Ordner in 'migrierte_daten' gefunden!");
            scanner.close();
            return;
        }
        
        // Zeige alle gefundenen Ordner
        System.out.println("Verfügbare Migration-Ordner:");
        for (int i = 0; i < migrationOrdner.size(); i++) {
            System.out.println((i + 1) + " = " + migrationOrdner.get(i));
        }
        
        System.out.print("Wähle Ordner (1-" + migrationOrdner.size() + "): ");
        int choice = Integer.parseInt(scanner.nextLine()) - 1;
        
        if (choice < 0 || choice >= migrationOrdner.size()) {
            System.err.println("FEHLER: Ungültige Auswahl!");
            scanner.close();
            return;
        }
        
        String gewaehlterOrdner = migrationOrdner.get(choice);
        
        // Zeige verfügbare Unterordner
        List<String> verfuegbareOrdner = findeVerfuegbareUnterordner(gewaehlterOrdner);
        
        if (verfuegbareOrdner.isEmpty()) {
            System.err.println("FEHLER: Keine SQL-Ordner gefunden!");
            scanner.close();
            return;
        }
        
        System.out.println("\nVerfügbare SQL-Ordner:");
        for (int i = 0; i < verfuegbareOrdner.size(); i++) {
            System.out.println((i + 1) + " = " + verfuegbareOrdner.get(i));
        }
        System.out.println((verfuegbareOrdner.size() + 1) + " = Alle Ordner");
        
        System.out.print("Wähle (1-" + (verfuegbareOrdner.size() + 1) + " oder mehrere mit Komma): ");
        String input = scanner.nextLine();
        
        String[] ausgewaehlteOrdner;
        
        if (input.contains(",")) {
            // Mehrere Ordner ausgewählt
            String[] indices = input.split(",");
            ausgewaehlteOrdner = new String[indices.length];
            for (int i = 0; i < indices.length; i++) {
                int idx = Integer.parseInt(indices[i].trim()) - 1;
                if (idx >= 0 && idx < verfuegbareOrdner.size()) {
                    ausgewaehlteOrdner[i] = verfuegbareOrdner.get(idx);
                }
            }
        } else {
            int idx = Integer.parseInt(input) - 1;
            if (idx == verfuegbareOrdner.size()) {
                // Alle Ordner
                ausgewaehlteOrdner = verfuegbareOrdner.toArray(new String[0]);
            } else if (idx >= 0 && idx < verfuegbareOrdner.size()) {
                // Einzelner Ordner
                ausgewaehlteOrdner = new String[]{verfuegbareOrdner.get(idx)};
            } else {
                System.err.println("FEHLER: Ungültige Auswahl!");
                scanner.close();
                return;
            }
        }
        
        try {
            importSQLFiles(gewaehlterOrdner, ausgewaehlteOrdner, gewaehlteVerbindung);
            System.out.println("INFO: Import erfolgreich abgeschlossen!");
        } catch (Exception e) {
            System.err.println("FEHLER beim Import: " + e.getMessage());
        }
        
        scanner.close();
    }
    
    private static List<String> findeAlleMigrationOrdner() {
        List<String> ordner = new ArrayList<>();
        
        // Suche in verschiedenen möglichen Pfaden
        String[] suchPfade = {
            "migrierte_daten",
            "dbtool-main/migrierte_daten", 
            "dbtool-main\\migrierte_daten",
            "./migrierte_daten",
            "../migrierte_daten"
        };
        
        for (String pfad : suchPfade) {
            File migrieteOrdner = new File(pfad);
            
            if (migrieteOrdner.exists() && migrieteOrdner.isDirectory()) {
                
                File[] unterordner = migrieteOrdner.listFiles(File::isDirectory);
                if (unterordner != null) {
                    for (File ordner1 : unterordner) {
                        String vollPfad = pfad + File.separator + ordner1.getName();
                        ordner.add(vollPfad);
                    }
                }
                break; // Ersten gefundenen Pfad verwenden
            }
        }
        
        return ordner;
    }
    
    private static List<String> findeVerfuegbareUnterordner(String basePath) {
        List<String> ordner = new ArrayList<>();
        File baseDir = new File(basePath);
        
        if (!baseDir.exists()) {
            return ordner;
        }
        
        File[] unterordner = baseDir.listFiles(File::isDirectory);
        if (unterordner != null) {
            for (File ordner1 : unterordner) {
                ordner.add(ordner1.getName());
            }
            // Sortiere alphabetisch
            Collections.sort(ordner);
        }
        
        return ordner;
    }
    
    private static boolean ladeAlleVerbindungen(String configFile) {
        try {
            Properties props = new Properties();
            
            // Versuche Properties-Datei zu laden
            File file = new File(configFile);
            if (!file.exists()) {
                System.err.println("FEHLER: Konfigurationsdatei nicht gefunden: " + configFile);
                System.err.println("INFO: Vollständiger Pfad: " + file.getAbsolutePath());
                System.err.println("INFO: Arbeitsverzeichnis: " + System.getProperty("user.dir"));
                
                // Prüfe alternative Dateinamen
                String[] alternativen = {
                    "config-sqlimporter.properties",
                    "sqlimporter-config.properties", 
                    "config.properties"
                };
                
                System.err.println("INFO: Suche nach alternativen Dateien...");
                for (String alt : alternativen) {
                    File altFile = new File(alt);
                    if (altFile.exists()) {
                        System.err.println("INFO: Alternative gefunden: " + alt);
                        System.err.println("INFO: Verwende: java ... SQLImporter " + alt);
                    }
                }
                
                return false;
            }
            
            props.load(new FileInputStream(file));
            System.out.println("INFO: Konfigurationsdatei erfolgreich geladen: " + configFile);
            
            // 1. Neue erweiterte postgres.name.url Syntax (mehrere Verbindungen)
            for (String key : props.stringPropertyNames()) {
                if (key.startsWith("postgres.") && key.endsWith(".url")) {
                    String verbindungsName = key.substring("postgres.".length(), key.length() - ".url".length());
                    
                    String url = props.getProperty("postgres." + verbindungsName + ".url");
                    String benutzer = props.getProperty("postgres." + verbindungsName + ".benutzer");
                    String passwort = props.getProperty("postgres." + verbindungsName + ".passwort");
                    
                    if (url != null && benutzer != null && passwort != null) {
                        Properties verbindungProps = new Properties();
                        verbindungProps.setProperty("url", url);
                        verbindungProps.setProperty("user", benutzer);
                        verbindungProps.setProperty("password", passwort);
                        
                        verbindungen.put(verbindungsName, verbindungProps);
                        System.out.println("INFO: PostgreSQL-Verbindung '" + verbindungsName + "' geladen: " + url);
                    }
                }
            }
            
            if (!verbindungen.isEmpty()) {
                System.out.println("INFO: " + verbindungen.size() + " postgres.*.url Verbindungen gefunden");
                return true;
            }
            
            // 2. Einfache postgres.* Syntax (eine Verbindung)
            String url = props.getProperty("postgres.url");
            String benutzer = props.getProperty("postgres.benutzer");
            String passwort = props.getProperty("postgres.passwort");
            
            if (url != null && benutzer != null && passwort != null) {
                Properties verbindungProps = new Properties();
                verbindungProps.setProperty("url", url);
                verbindungProps.setProperty("user", benutzer);
                verbindungProps.setProperty("password", passwort);
                
                verbindungen.put("postgres", verbindungProps);
                System.out.println("INFO: PostgreSQL-Verbindung geladen: " + url);
                return true;
            }
            
            // Fallback: Alte Variante mit postgresql.*.host Einträgen
            for (String key : props.stringPropertyNames()) {
                if (key.startsWith("postgresql.") && key.endsWith(".host")) {
                    String verbindungsName = key.substring("postgresql.".length(), key.length() - ".host".length());
                    
                    Properties verbindungProps = new Properties();
                    verbindungProps.setProperty("host", props.getProperty("postgresql." + verbindungsName + ".host"));
                    verbindungProps.setProperty("port", props.getProperty("postgresql." + verbindungsName + ".port", "5432"));
                    verbindungProps.setProperty("database", props.getProperty("postgresql." + verbindungsName + ".database"));
                    verbindungProps.setProperty("user", props.getProperty("postgresql." + verbindungsName + ".user"));
                    verbindungProps.setProperty("password", props.getProperty("postgresql." + verbindungsName + ".password"));
                    
                    verbindungen.put(verbindungsName, verbindungProps);
                    System.out.println("INFO: Verbindung '" + verbindungsName + "' geladen");
                }
            }
            
            if (!verbindungen.isEmpty()) {
                System.out.println("INFO: " + verbindungen.size() + " postgresql.* Verbindungen gefunden");
                return true;
            }
            
            // Fallback 2: Einfache postgresql.* properties
            if (verbindungen.isEmpty()) {
                String host = props.getProperty("postgresql.host");
                String port = props.getProperty("postgresql.port", "5432");
                String database = props.getProperty("postgresql.database");
                String user = props.getProperty("postgresql.user");
                String password = props.getProperty("postgresql.password");
                
                if (host != null && database != null && user != null && password != null) {
                    Properties verbindungProps = new Properties();
                    verbindungProps.setProperty("host", host);
                    verbindungProps.setProperty("port", port);
                    verbindungProps.setProperty("database", database);
                    verbindungProps.setProperty("user", user);
                    verbindungProps.setProperty("password", password);
                    
                    verbindungen.put("default", verbindungProps);
                    System.out.println("INFO: Standard-Verbindung 'default' geladen");
                }
            }
            
            return !verbindungen.isEmpty();
            
        } catch (Exception e) {
            System.err.println("FEHLER beim Laden der Konfiguration: " + e.getMessage());
            return false;
        }
    }
    
    private static String waehleVerbindung() {
        if (verbindungen.size() == 1) {
            return verbindungen.keySet().iterator().next();
        }
        
        System.out.println("\nVerfügbare Datenbankverbindungen:");
        
        List<String> verbindungsListe = new ArrayList<>(verbindungen.keySet());
        for (int i = 0; i < verbindungsListe.size(); i++) {
            String name = verbindungsListe.get(i);
            Properties props = verbindungen.get(name);
            
            // Prüfe ob es eine direkte URL ist
            String url = props.getProperty("url");
            if (url != null) {
                System.out.println((i + 1) + " = " + name + " (" + url + ")");
            } else {
                // Alte Variante mit Host/Port/Database
                String host = props.getProperty("host", "unbekannt");
                String port = props.getProperty("port", "5432");
                String database = props.getProperty("database", "unbekannt");
                System.out.println((i + 1) + " = " + name + " (" + host + ":" + port + "/" + database + ")");
            }
        }
        
        Scanner scanner = new Scanner(System.in);
        System.out.print("Wähle Verbindung (1-" + verbindungsListe.size() + "): ");
        try {
            int choice = Integer.parseInt(scanner.nextLine()) - 1;
            if (choice >= 0 && choice < verbindungsListe.size()) {
                return verbindungsListe.get(choice);
            }
        } catch (NumberFormatException e) {
            System.err.println("Ungültige Eingabe!");
        }
        
        return null;
    }
    
    private static Connection getConnection(String verbindungsName) throws SQLException {
        Properties props = verbindungen.get(verbindungsName);
        
        // Neue Variante: Direkte URL
        String url = props.getProperty("url");
        if (url != null) {
            return DriverManager.getConnection(url, props.getProperty("user"), props.getProperty("password"));
        }
        
        // Alte Variante: Host/Port/Database zusammenbauen
        url = "jdbc:postgresql://" + props.getProperty("host") + ":" + 
              props.getProperty("port") + "/" + props.getProperty("database");
        
        return DriverManager.getConnection(url, props.getProperty("user"), props.getProperty("password"));
    }
    
    public static void importSQLFiles(String basePath, String[] ordnerZuImportieren, String verbindungsName) throws SQLException, IOException {
        // PostgreSQL Driver laden
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            System.err.println("FEHLER: PostgreSQL JDBC Driver nicht gefunden!");
            throw new SQLException("Driver nicht gefunden", e);
        }
        
        Connection conn = getConnection(verbindungsName);
        conn.setAutoCommit(true);
        
        System.out.println("INFO: Datenbankverbindung erfolgreich hergestellt");
        
        int gesamteDateien = 0;
        int erfolgreicheDateien = 0;
        List<String> fehlgeschlageneTabellen = new ArrayList<>();
        
        for (String ordner : ordnerZuImportieren) {
            if (ordner == null) continue;
            
            String ordnerPfad = basePath + File.separator + ordner;
            File ordnerFile = new File(ordnerPfad);
            
            if (!ordnerFile.exists()) {
                System.out.println("WARNUNG: Ordner '" + ordner + "' nicht gefunden - überspringe");
                continue;
            }
            
            File[] sqlDateien = ordnerFile.listFiles((dir, name) -> name.toLowerCase().endsWith(".sql"));
            
            if (sqlDateien != null && sqlDateien.length > 0) {
                Arrays.sort(sqlDateien);
                
                for (File sqlDatei : sqlDateien) {
                    boolean dateiErfolgreich = fuehreSQLDateiAus(conn, sqlDatei);
                    gesamteDateien++;
                    
                    if (dateiErfolgreich) {
                        erfolgreicheDateien++;
                    } else {
                        // Extrahiere Tabellenname aus Dateiname (entferne .sql)
                        String tabellenName = sqlDatei.getName().replaceAll("\\.sql$", "");
                        fehlgeschlageneTabellen.add(tabellenName);
                    }
                }
            } else {
                System.out.println("   WARNUNG: Keine SQL-Dateien gefunden");
            }
        }
        
        conn.close();
        
        // Detaillierte Statistik ausgeben
        System.out.println("\n" + new String(new char[60]).replace("\0", "="));
        System.out.println("MIGRATION ABGESCHLOSSEN - ZUSAMMENFASSUNG");
        System.out.println("\n" + new String(new char[60]).replace("\0", "="));
        System.out.println("Gesamt verarbeitete Dateien: " + gesamteDateien);
        System.out.println("Erfolgreich migriert: " + erfolgreicheDateien);
        System.out.println("Fehlgeschlagen: " + fehlgeschlageneTabellen.size());
        
        if (!fehlgeschlageneTabellen.isEmpty()) {
            System.out.println("\nFEHLGESCHLAGENE TABELLEN/DATEIEN:");
            for (String tabelle : fehlgeschlageneTabellen) {
                System.out.println("  - " + tabelle);
            }
        }
        
        if (fehlgeschlageneTabellen.isEmpty()) {
            System.out.println("\nSTATUS: Alle Dateien erfolgreich migriert!");
        } else {
            System.err.println("\nSTATUS: Migration mit Fehlern abgeschlossen!");
        }
        System.out.println("\n" + new String(new char[60]).replace("\0", "="));
    }
    
    private static boolean fuehreSQLDateiAus(Connection conn, File sqlDatei) throws IOException, SQLException {
        String inhalt = new String (Files.readAllBytes(sqlDatei.toPath()), StandardCharsets.UTF_8);

        // Bereinige den Inhalt - entferne nur echte Kommentarzeilen, nicht COMMENT ON statements
        String bereinigterInhalt = bereinigeKommentare(inhalt);

        // Statement aufteilen
        String[] statements = bereinigterInhalt.split("(?<!\\\\);"); // nur echtes Semikolon (nicht escaped)

        boolean alleStatementsErfolgreich = true;

        try (Statement stmt = conn.createStatement()) {
            for (String statement : statements) {
                String sql = statement.trim();
                if (!sql.isEmpty()) {
                    try {
                        stmt.execute(sql);
                    } catch (SQLException e) {
                        alleStatementsErfolgreich = false;
                        System.err.println("      FEHLER: " + e.getMessage());
                        // Optional: throw e; // Um bei Fehler komplett abzubrechen
                    }
                }
            }
        }
        
        return alleStatementsErfolgreich;
    }
    
    /**
     * Bereinigt SQL-Kommentare, aber behält COMMENT ON statements bei
     */
    private static String bereinigeKommentare(String sql) {
        StringBuilder result = new StringBuilder();
        String[] lines = sql.split("\n");
        boolean inBlockComment = false;
        
        for (String line : lines) {
            String trimmedLine = line.trim();
            
            // Prüfe ob es ein COMMENT ON statement ist - diese behalten wir
            if (trimmedLine.toUpperCase().startsWith("COMMENT ON")) {
                result.append(line).append("\n");
                continue;
            }
            
            // Block-Kommentare (/* ... */)
            if (trimmedLine.contains("/*")) {
                if (trimmedLine.contains("*/")) {
                    // Ein-Zeilen Block-Kommentar - entfernen
                    String beforeComment = line.substring(0, line.indexOf("/*"));
                    String afterComment = "";
                    int endIndex = line.indexOf("*/") + 2;
                    if (endIndex < line.length()) {
                        afterComment = line.substring(endIndex);
                    }
                    String cleanedLine = beforeComment + afterComment;
                    if (!cleanedLine.trim().isEmpty()) {
                        result.append(cleanedLine).append("\n");
                    }
                } else {
                    // Beginn eines mehrzeiligen Block-Kommentars
                    inBlockComment = true;
                    String beforeComment = line.substring(0, line.indexOf("/*"));
                    if (!beforeComment.trim().isEmpty()) {
                        result.append(beforeComment).append("\n");
                    }
                }
                continue;
            }
            
            if (inBlockComment) {
                if (trimmedLine.contains("*/")) {
                    // Ende des Block-Kommentars
                    inBlockComment = false;
                    int endIndex = line.indexOf("*/") + 2;
                    if (endIndex < line.length()) {
                        String afterComment = line.substring(endIndex);
                        if (!afterComment.trim().isEmpty()) {
                            result.append(afterComment).append("\n");
                        }
                    }
                }
                continue;
            }
            
            // Zeilen-Kommentare (--) - aber nur wenn sie am Anfang der Zeile stehen
            if (trimmedLine.startsWith("--")) {
                continue; // Überspringe diese Zeile
            }
            
            // Entferne Inline-Kommentare (-- am Ende der Zeile)
            if (line.contains("--")) {
                int commentIndex = line.indexOf("--");
                // Prüfe ob das -- in einem String steht (einfache Prüfung)
                String beforeComment = line.substring(0, commentIndex);
                long singleQuotes = beforeComment.chars().filter(ch -> ch == '\'').count();
                long doubleQuotes = beforeComment.chars().filter(ch -> ch == '"').count();
                
                // Wenn ungerade Anzahl von Anführungszeichen, dann ist -- in einem String
                if (singleQuotes % 2 == 0 && doubleQuotes % 2 == 0) {
                    line = beforeComment.trim();
                }
            }
            
            if (!line.trim().isEmpty()) {
                result.append(line).append("\n");
            }
        }
        
        return result.toString();
    }

}
